# Define the base folder and script paths at the beginning of the script


$baseFolderPath = "C:\Power BI Backups"



$Script1Path = "$baseFolderPath\Config\Report Detail Extract Script-PBIR.csx"
$Script2Path = "$baseFolderPath\Config\Report Detail Extract Script.csx"
$Script3Path = "$baseFolderPath\Config\Model Detail Extract Script.csx"
$Script4Path = "$baseFolderPath\Config\Measure Dependency Extract Script.csx"
$TabularEditor2Path = "$baseFolderPath\Config\TabularEditor\TabularEditor.exe"

# =============================
# Config
# =============================
$baseFolderPath = "C:\Power BI Backups"
$configFolder   = Join-Path $baseFolderPath "Config"

# Ensure Config exists
if (-not (Test-Path $configFolder)) {
    New-Item -Path $configFolder -ItemType Directory -Force | Out-Null
}

$ErrorActionPreference="SilentlyContinue"; $WarningPreference="SilentlyContinue"

# Temporarily set execution policy to Bypass for this session
if ((Get-ExecutionPolicy) -ne 'Bypass') {
    Write-Host "Temporarily setting Execution Policy to Bypass for this session..."
    Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
}

# =============================
# Download latest pbi-tools
# =============================
$pbiToolsZip = Join-Path $configFolder "PBI Tools.zip"

Write-Host "[INFO] Fetching latest pbi-tools release..."
$pbiRelease = Invoke-RestMethod -Uri "https://api.github.com/repos/pbi-tools/pbi-tools/releases/latest"
$pbiAsset   = $pbiRelease.assets | Where-Object { $_.name -like "*.zip" } | Select-Object -First 1

if ($pbiAsset -and $pbiAsset.browser_download_url) {
    if (Test-Path $pbiToolsZip) { Remove-Item $pbiToolsZip -Force }
    Invoke-WebRequest -Uri $pbiAsset.browser_download_url -OutFile $pbiToolsZip -UseBasicParsing
    Write-Host "[INFO] Downloaded latest pbi-tools to $pbiToolsZip"
} else {
    Write-Warning "[WARN] Could not find a valid pbi-tools zip asset."
}

# =============================
Download latest Tabular Editor 2 Portable
# =============================
$teZip = Join-Path $configFolder "TabularEditor.zip"
$teDownloadUrl = "https://github.com/TabularEditor/TabularEditor/releases/latest/download/TabularEditor.Portable.zip"

Write-Host "[INFO] Downloading latest Tabular Editor 2 Portable..."
if (Test-Path $teZip) { Remove-Item $teZip -Force }
Invoke-WebRequest -Uri $teDownloadUrl -OutFile $teZip -UseBasicParsing
Write-Host "[INFO] Downloaded Tabular Editor 2 Portable to $teZip"

# Define the folder path and zip pattern for PBI Tools
$PBIToolsFolderPath = Join-Path -Path $baseFolderPath\Config -ChildPath "PBI Tools"
$PBIToolsZipPattern = "PBI Tools*.zip"

# Get the first matching zip file
$zipFile = Get-ChildItem -Path $baseFolderPath\Config -Filter $PBIToolsZipPattern | Select-Object -First 1
if ($zipFile) {
    # Remove the folder if it already exists
    if (Test-Path -Path $PBIToolsFolderPath) {
        Remove-Item -Path $PBIToolsFolderPath -Recurse -Force
    }

    # Recreate the folder
    New-Item -Path $PBIToolsFolderPath -ItemType Directory -Force | Out-Null

    # Extract the zip file contents into the folder
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    [System.IO.Compression.ZipFile]::ExtractToDirectory($zipFile.FullName, $PBIToolsFolderPath)
    Write-Output "Extracted $($zipFile.Name) to $PBIToolsFolderPath"
}

# Repeat for Tabular Editor
$TabularEditorFolderPath = Join-Path -Path $baseFolderPath\Config -ChildPath "TabularEditor"
$TabularEditorZipPattern = "TabularEditor*.zip"

$zipFile = Get-ChildItem -Path $baseFolderPath\Config -Filter $TabularEditorZipPattern | Select-Object -First 1
if ($zipFile) {
    if (Test-Path -Path $TabularEditorFolderPath) {
        Remove-Item -Path $TabularEditorFolderPath -Recurse -Force
    }

    New-Item -Path $TabularEditorFolderPath -ItemType Directory -Force | Out-Null

    Add-Type -AssemblyName System.IO.Compression.FileSystem
    [System.IO.Compression.ZipFile]::ExtractToDirectory($zipFile.FullName, $TabularEditorFolderPath)
    Write-Output "Extracted $($zipFile.Name) to $TabularEditorFolderPath"
} else {
    Write-Host "No zip file matching the pattern $TabularEditorZipPattern found in $baseFolderPath\Config"
}


$pbiToolsPath = Join-Path -Path $baseFolderPath -ChildPath "Config\PBI Tools\pbi-tools.exe"


# Ensure required modules are installed, and imports them. If import fails, error and exit early
$requiredModules = @( 'ImportExcel', 'MicrosoftPowerBIMgmt' )
foreach ($module in $requiredModules) {
    if( -not (Import-Module $module -PassThru -EA ignore) ) {
       Install-Module -Name $module -Scope CurrentUser -Force
    }

    Import-Module $Module -ErrorAction 'stop' # In the rare case Install-Module fails, you probably want a terminating error
}


# Connect to the Power BI Service
function Connect-PowerBI {
    Connect-PowerBIServiceAccount
    $global:accessTokenObject = Get-PowerBIAccessToken
    $global:accessToken = $accessTokenObject.Authorization -replace 'Bearer ', ''
    # Write the access token to a temporary file
    Set-Content -Path $env:TEMP\PowerBI_AccessToken.txt -Value $global:accessToken
}

# Track script start time
$scriptStartTime = Get-Date
Connect-PowerBI

# Function to refresh the token in a background job
function Start-TokenRefreshJob {
    $jobScript = {
        function Connect-PowerBI {
            Connect-PowerBIServiceAccount
            $global:accessTokenObject = Get-PowerBIAccessToken
            $global:accessToken = $accessTokenObject.Authorization -replace 'Bearer ', ''
            # Write the access token to a temporary file
            Set-Content -Path $env:TEMP\PowerBI_AccessToken.txt -Value $global:accessToken
        }
        while ($true) {
            Start-Sleep -Seconds 3300  # Sleep for 55 minutes
            Connect-PowerBI
        }
    }
    Start-Job -ScriptBlock $jobScript -Name "TokenRefreshJob"
}

# Start the background job to refresh the token
Start-TokenRefreshJob

# Function to get the current access token
function Get-CurrentAccessToken {
    $global:accessToken = Get-Content -Path $env:TEMP\PowerBI_AccessToken.txt
    return $global:accessToken
}

# Create a variable date
$date = (Get-Date -UFormat "%Y-%m-%d")








#### Start of Power BI Environment Detail Extract ####







Write-Output "Power BI Environment Detail Extract Process Started"

# Define the Information Extract Excel file path
$excelFile = "$baseFolderPath\Power BI Environment Detail.xlsx"

# Function to rename properties in objects and handle duplicates
function Rename-Properties {
    param ($object, $renameMap)
    $newObject = New-Object PSObject
    foreach ($originalName in $renameMap.Keys) {
        $newPropertyName = $renameMap[$originalName]
        $propertyValue = if ($object.PSObject.Properties[$originalName]) { $object.$originalName } else { $null }
        if ($newObject.PSObject.Properties[$newPropertyName]) { $newPropertyName += "_duplicate" }
        $newObject | Add-Member -MemberType NoteProperty -Name $newPropertyName -Value $propertyValue
    }
    foreach ($property in $object.PSObject.Properties) {
        if (-not $renameMap.ContainsKey($property.Name)) {
            $newObject | Add-Member -MemberType NoteProperty -Name $property.Name -Value $property.Value
        }
    }
    return $newObject
}

function Show-WorkspacePicker {
    param(
        [Parameter(Mandatory)]
        [array]$Workspaces # array of PSCustomObjects with id + name
    )

    Add-Type -AssemblyName System.Windows.Forms
    Add-Type -AssemblyName System.Drawing

    # Form
    $form               = New-Object System.Windows.Forms.Form
    $form.Text          = "Select Workspaces"
    $form.StartPosition = 'CenterScreen'
    $form.Size          = New-Object System.Drawing.Size(520,540)
    $form.TopMost       = $true

    # Instruction label
    $lbl                = New-Object System.Windows.Forms.Label
    $lbl.Text           = "Select the workspaces to run against:"
    $lbl.AutoSize       = $true
    $lbl.Location       = New-Object System.Drawing.Point(12,12)
    $form.Controls.Add($lbl)

    # CheckedListBox
    $clb                = New-Object System.Windows.Forms.CheckedListBox
    $clb.Location       = New-Object System.Drawing.Point(12,40)
    $clb.Size           = New-Object System.Drawing.Size(480,380)
    $clb.CheckOnClick   = $true
    $clb.Sorted         = $true

    foreach ($ws in $Workspaces) {
        $display = "{0} ({1})" -f $ws.name, $ws.id
        [void]$clb.Items.Add([pscustomobject]@{ Display=$display; Id=$ws.id; Name=$ws.name })
    }
    $clb.DisplayMember = 'Display'
    $form.Controls.Add($clb)

    # "Select All" checkbox
    $chkAll            = New-Object System.Windows.Forms.CheckBox
    $chkAll.Text       = "Select All"
    $chkAll.AutoSize   = $true
    $chkAll.Location   = New-Object System.Drawing.Point(12,430)
    $chkAll.Add_CheckedChanged({
        for ($i=0; $i -lt $clb.Items.Count; $i++) {
            $clb.SetItemChecked($i, $chkAll.Checked)
        }
    })
    $form.Controls.Add($chkAll)

    # "Include My Workspace" checkbox
    $chkMy             = New-Object System.Windows.Forms.CheckBox
    $chkMy.Text        = "Include 'My Workspace'"
    $chkMy.AutoSize    = $true
    $chkMy.Location    = New-Object System.Drawing.Point(120,430)
    $chkMy.Checked     = $false
    $form.Controls.Add($chkMy)

    # OK button
    $okBtn             = New-Object System.Windows.Forms.Button
    $okBtn.Text        = "OK"
    $okBtn.Width       = 100
    $okBtn.Location    = New-Object System.Drawing.Point(286,470)
    $okBtn.Add_Click({
        $form.Tag = 'OK'
        $form.Close()
    })
    $form.Controls.Add($okBtn)

    # Cancel button
    $cancelBtn         = New-Object System.Windows.Forms.Button
    $cancelBtn.Text    = "Cancel"
    $cancelBtn.Width   = 100
    $cancelBtn.Location= New-Object System.Drawing.Point(392,470)
    $cancelBtn.Add_Click({
        $form.Tag = 'Cancel'
        $form.Close()
    })
    $form.Controls.Add($cancelBtn)

    # Timer (auto-close after 25s)
    $timer = New-Object System.Windows.Forms.Timer
    $timer.Interval = 25000
    $timer.Add_Tick({
        $timer.Stop()
        $form.Tag = 'Timeout'
        $form.Close()
    })
    $timer.Start()

    [void]$form.ShowDialog()

    # Gather selections
    $selectedIds = @()
    foreach ($item in $clb.CheckedItems) {
        $selectedIds += $item.Id
    }

    if ($form.Tag -eq 'Cancel') {
        throw "User cancelled workspace selection."
    }

    $timedOut = ($form.Tag -eq 'Timeout')

    # If nothing selected (or you want to keep your previous behavior), default to all
    if ($selectedIds.Count -eq 0) {
        $selectedIds = $Workspaces.id
    }

    # Include My Workspace only if checked… except on timeout, then force include
    $includeMy = if ($timedOut) { $true } else { $chkMy.Checked }

    return [pscustomobject]@{
        SelectedWorkspaceIds = $selectedIds
        IncludeMyWorkspace   = $includeMy
        TimedOut             = $timedOut
    }
}



# Define renaming maps for each type of object
$workspaceRenameMap = @{
    "id" = "WorkspaceId";
    "name" = "WorkspaceName";
    "isReadOnly" = "WorkspaceIsReadOnly";
    "isOnDedicatedCapacity" = "WorkspaceIsOnDedicatedCapacity";
    "capacityId" = "WorkspaceCapacityId";
    "defaultDatasetStorageFormat" = "WorkspaceDefaultDatasetStorageFormat";
    "type" = "WorkspaceType"
}

$datasetRenameMap = @{
    "id" = "DatasetId";
    "name" = "DatasetName";
    "description" = "DatasetDescription";
    "webUrl" = "DatasetWebUrl";
    "addRowsAPIEnabled" = "DatasetAddRowsAPIEnabled";
    "configuredBy" = "DatasetConfiguredBy";
    "isRefreshable" = "DatasetIsRefreshable";
    "isEffectiveIdentityRequired" = "DatasetIsEffectiveIdentityRequired";
    "isEffectiveIdentityRolesRequired" = "DatasetIsEffectiveIdentityRolesRequired";
    "isOnPremGatewayRequired" = "DatasetIsOnPremGatewayRequired";
    "targetStorageMode" = "DatasetTargetStorageMode";
    "queryScaleOutSettings" = "DatasetQueryScaleOutSettings";
    "createdDate" = "DatasetCreatedDate"
}

$datasetDatasourceRenameMap = @{
    "datasourceType" = "DatasetDatasourceType";
    "datasourceId" = "DatasetDatasourceId";
    "gatewayId" = "DatasetDatasourceGatewayId";
    "connectionDetails" = "DatasetDatasourceConnectionDetails"
}

$dataflowDatasourceRenameMap = @{
    "datasourceType" = "DataflowDatasourceType";
    "datasourceId" = "DataflowDatasourceId";
    "gatewayId" = "DataflowDatasourceGatewayId";
    "connectionDetails" = "DataflowDatasourceConnectionDetails"
}

$datasetRefreshRenameMap = @{
    "requestId" = "DatasetRefreshRequestId";
    "id" = "DatasetRefreshId";
    "startTime" = "DatasetRefreshStartTime";
    "endTime" = "DatasetRefreshEndTime";
    "status" = "DatasetRefreshStatus";
    "refreshType" = "DatasetRefreshType"
}

$dataflowRefreshRenameMap = @{
    "requestId" = "DataflowRefreshRequestId";
    "id" = "DataflowRefreshId";
    "startTime" = "DataflowRefreshStartTime";
    "endTime" = "DataflowRefreshEndTime";
    "status" = "DataflowRefreshStatus" ;
    "refreshType" = "DataflowRefreshType" ;
    "errorInfo" = "DataflowErrorInfo"
}

$dataflowRenameMap = @{
    "configuredBy"      = "DataflowConfiguredBy";
    "description"       = "DataflowDescription";
    "modelUrl"         = "DataflowJsonURL";
    "modifiedBy"       = "DataflowModifiedBy";
    "modifiedDateTime" = "DataflowModifiedDateTime";
    "name"             = "DataflowName";
    "objectId"         = "DataflowId";
    "generation" = "DataflowGeneration"
}

$dataflowLineageRenameMap = @{
    "datasetObjectId"   = "DatasetId";
    "dataflowObjectId"  = "DataflowId";
    "workspaceObjectId" = "WorkspaceId"
}

$reportRenameMap = @{
    "id" = "ReportId";
    "name" = "ReportName";
    "description" = "ReportDescription";
    "webUrl" = "ReportWebUrl";
    "embedUrl" = "ReportEmbedUrl";
    "isFromPbix" = "ReportIsFromPbix";
    "isOwnedByMe" = "ReportIsOwnedByMe";
    "datasetId" = "DatasetId";
    "datasetWorkspaceId" = "DatasetWorkspaceId";
    "reportType" = "ReportType"
}

$pageRenameMap = @{
    "name" = "PageName";
    "displayName" = "PageDisplayName";
    "order" = "PageOrder"
}

$appRenameMap = @{
    "id" = "AppId";
    "name" = "AppName";
    "lastUpdate" = "AppLastUpdate";
    "description" = "AppDescription";
    "publishedBy" = "AppPublishedBy";
    "workspaceId" = "AppWorkspaceId";
    "users" = "AppUsers"
}

$appReportRenameMap = @{
    "id" = "AppReportId";
    "reportType" = "AppReportType";
    "name" = "ReportName";
    "webUrl" = "AppReportWebUrl";
    "embedUrl" = "AppReportEmbedUrl";
    "isOwnedByMe" = "AppReportIsOwnedByMe";
    "datasetId" = "AppReportDatasetId";
    "originalReportObjectId" = "ReportId";
    "users" = "AppUsers";
    "subscriptions" = "AppReportSubscriptions";
    "sections" = "AppReportSections"
}

# Define renaming map for Fabric Items
$fabricItemsRenameMap = @{
    "id" = "FabricItemID";
    "type" = "FabricItemType";
    "displayName" = "FabricItemName";
    "description" = "FabricItemDescription"
}



# Fetch and filter workspaces
$workspacesUrl = "https://api.powerbi.com/v1.0/myorg/groups"
$workspacesResponse = Invoke-PowerBIRestMethod -Method GET -Url $workspacesUrl | ConvertFrom-Json
$workspacesInfo = @()

# --- Try WinForms picker; fallback if GUI not available ---
try {
    $selection = Show-WorkspacePicker -Workspaces $workspacesResponse.value
}
catch {
    Write-Warning "WinForms not available. Defaulting to ALL workspaces and INCLUDING My Workspace."
    $selection = [pscustomobject]@{
        SelectedWorkspaceIds = $workspacesResponse.value.id
        IncludeMyWorkspace   = $true
    }
}

# Build filtered workspaces
$selectedWorkspaceIds = @($selection.SelectedWorkspaceIds)

if (-not $selectedWorkspaceIds -or $selectedWorkspaceIds.Count -eq 0) {
    throw "No workspaces selected."
}

foreach ($workspace in $workspacesResponse.value) {
    if ($selectedWorkspaceIds -notcontains $workspace.id) { continue }
    $workspacesInfo += Rename-Properties -object $workspace -renameMap $workspaceRenameMap
}

# Flag for later "My Workspace" section
$IncludeMyWorkspace = $selection.IncludeMyWorkspace


# Initialize collections for all necessary information
$fabricItemsInfo = @()
$datasetsInfo = @()
$datasetSourcesInfo = @()
$dataflowsInfo = @()
$dataflowLineage = @()
$dataflowSourcesInfo = @()
$reportsInfo = @()
$reportPagesInfo = @()
$appsInfo = @()
$reportsInAppInfo = @()
$datasetNameLookup = @{}
$dataflowNameLookup = @{}
$datasetRefreshHistory = @()
$dataflowRefreshHistory = @()


# Loop through filtered workspaces
foreach ($workspace in $workspacesInfo) {

Write-Output "Workspace [$($workspace.WorkspaceName)] Report & Model metadata extraction process started."

    # Fetch datasets
    $datasetsUrl = "https://api.powerbi.com/v1.0/myorg/groups/$($workspace.WorkspaceId)/datasets"
    $datasets = Invoke-PowerBIRestMethod -Method GET -Url $datasetsUrl | ConvertFrom-Json

    foreach ($dataset in $datasets.value) {
        $renamedDataset = Rename-Properties -object $dataset -renameMap $datasetRenameMap
        $renamedDataset | Add-Member -NotePropertyName "WorkspaceId" -NotePropertyValue $workspace.WorkspaceId -Force
        $renamedDataset | Add-Member -NotePropertyName "WorkspaceName" -NotePropertyValue $workspace.WorkspaceName -Force
        
    # Store the DatasetId and DatasetName in the lookup table
        $datasetNameLookup[$dataset.id] = $dataset.name
        $datasetsInfo += $renamedDataset

        # Fetch dataset sources
        $datasourcesUrl = "https://api.powerbi.com/v1.0/myorg/groups/$($workspace.WorkspaceId)/datasets/$($dataset.id)/datasources"
        $datasources = Invoke-PowerBIRestMethod -Method GET -Url $datasourcesUrl | ConvertFrom-Json

        foreach ($datasource in $datasources.value) {
            $renamedDatasource = Rename-Properties -object $datasource -renameMap $datasetDatasourceRenameMap
            $renamedDatasource | Add-Member -NotePropertyName "WorkspaceId" -NotePropertyValue $workspace.WorkspaceId -Force
            $renamedDatasource | Add-Member -NotePropertyName "WorkspaceName" -NotePropertyValue $workspace.WorkspaceName -Force
            $renamedDatasource | Add-Member -NotePropertyName "DatasetId" -NotePropertyValue $dataset.id -Force
            $renamedDatasource | Add-Member -NotePropertyName "DatasetName" -NotePropertyValue $dataset.name -Force
            if ($datasource.connectionDetails) {
                $renamedDatasource.DatasetDatasourceConnectionDetails = $datasource.connectionDetails | ConvertTo-Json -Compress
            }
            $datasetSourcesInfo += $renamedDatasource
        }
    }

    # Fetch reports
    $reportsUrl = "https://api.powerbi.com/v1.0/myorg/groups/$($workspace.WorkspaceId)/reports"
    $reports = Invoke-PowerBIRestMethod -Method GET -Url $reportsUrl | ConvertFrom-Json

	# Create a hash set to store Report IDs
	$reportIds = @{}

    foreach ($report in $reports.value) {
        $renamedReport = Rename-Properties -object $report -renameMap $reportRenameMap
        $renamedReport | Add-Member -NotePropertyName "WorkspaceId" -NotePropertyValue $workspace.WorkspaceId -Force
        $renamedReport | Add-Member -NotePropertyName "WorkspaceName" -NotePropertyValue $workspace.WorkspaceName -Force


        # Retrieve and add the correct DatasetName from the lookup table if DatasetId exists
        $datasetId = $report.datasetId
        if ($datasetId -and $datasetNameLookup.ContainsKey($datasetId)) {
            $renamedReport | Add-Member -NotePropertyName "DatasetName" -NotePropertyValue $datasetNameLookup[$datasetId] -Force
        } else {
            $renamedReport | Add-Member -NotePropertyName "DatasetName" -NotePropertyValue "Unknown Dataset" -Force
        }

        $reportsInfo += $renamedReport

        # Fetch report pages
        $pagesUrl = "https://api.powerbi.com/v1.0/myorg/groups/$($workspace.WorkspaceId)/reports/$($report.id)/pages"
        $pages = Invoke-PowerBIRestMethod -Method GET -Url $pagesUrl | ConvertFrom-Json
        foreach ($page in $pages.value) {
            $renamedPage = Rename-Properties -object $page -renameMap $pageRenameMap
            $renamedPage | Add-Member -NotePropertyName "WorkspaceId" -NotePropertyValue $workspace.WorkspaceId -Force
            $renamedPage | Add-Member -NotePropertyName "WorkspaceName" -NotePropertyValue $workspace.WorkspaceName -Force
            $renamedPage | Add-Member -NotePropertyName "ReportId" -NotePropertyValue $report.id -Force
            $renamedPage | Add-Member -NotePropertyName "ReportName" -NotePropertyValue $report.name -Force
            $reportPagesInfo += $renamedPage

            # Store the report ID in the hash set
            $reportIds[$report.id] = $true
        }
    }
Write-Output "Workspace [$($workspace.WorkspaceName)] Report & Model metadata extraction process completed."
}

# Fetch Apps and App Reports that are in filtered workspaces
$appsUrl = "https://api.powerbi.com/v1.0/myorg/apps"
$apps = Invoke-PowerBIRestMethod -Method GET -Url $appsUrl | ConvertFrom-Json

# Create a hash set to store App Report IDs
$appReportIds = @{}
$originalReportObjectIds = @{}

foreach ($app in $apps.value) {
    if ($workspacesInfo.WorkspaceId -contains $app.workspaceId) {
        $renamedApp = Rename-Properties -object $app -renameMap $appRenameMap
        $appsInfo += $renamedApp

        # Fetch reports within each app
        $appReportsUrl = "https://api.powerbi.com/v1.0/myorg/apps/$($app.id)/reports"
        $appReports = Invoke-PowerBIRestMethod -Method GET -Url $appReportsUrl | ConvertFrom-Json

        foreach ($report in $appReports.value) {
            $renamedAppReport = Rename-Properties -object $report -renameMap $appReportRenameMap
            $renamedAppReport | Add-Member -NotePropertyName "AppId" -NotePropertyValue $app.id -Force
            $renamedAppReport | Add-Member -NotePropertyName "AppName" -NotePropertyValue $app.name -Force
            $reportsInAppInfo += $renamedAppReport

            # Store the app report ID in the hash set
            $appReportIds[$report.id] = $true
            $originalReportObjectIds[$report.originalReportObjectId] = $true
        }
    }
}

# Fetch Refresh History for Datasets
foreach ($workspace in $workspacesInfo) {

Write-Output "Workspace [$($workspace.WorkspaceName)] Model Refresh History extraction process started."

    foreach ($dataset in $datasetsInfo | Where-Object { $_.WorkspaceId -eq $workspace.WorkspaceId }) {
        $refreshHistoryUrl = "https://api.powerbi.com/v1.0/myorg/groups/$($workspace.WorkspaceId)/datasets/$($dataset.DatasetId)/refreshes"
        $refreshHistoryResponse = Invoke-PowerBIRestMethod -Method GET -Url $refreshHistoryUrl | ConvertFrom-Json

        foreach ($refresh in $refreshHistoryResponse.value) {
            $renamedRefreshRecord = Rename-Properties -object $refresh -renameMap $datasetRefreshRenameMap
            $renamedRefreshRecord | Add-Member -NotePropertyName "WorkspaceId" -NotePropertyValue $workspace.WorkspaceId -Force
            $renamedRefreshRecord | Add-Member -NotePropertyName "WorkspaceName" -NotePropertyValue $workspace.WorkspaceName -Force
            $renamedRefreshRecord | Add-Member -NotePropertyName "DatasetId" -NotePropertyValue $dataset.DatasetId -Force
            $renamedRefreshRecord | Add-Member -NotePropertyName "DatasetName" -NotePropertyValue $dataset.DatasetName -Force

            $datasetRefreshHistory += $renamedRefreshRecord
        }
    }
Write-Output "Workspace [$($workspace.WorkspaceName)] Model Refresh History extraction process completed."
}  


# Fetch Dataflows for Workspaces
foreach ($workspace in $workspacesInfo) {

Write-Output "Workspace [$($workspace.WorkspaceName)] Dataflow metadata extraction process started."

    $dataflowsUrl = "https://api.powerbi.com/v1.0/myorg/groups/$($workspace.WorkspaceId)/dataflows"
    $dataflowsResponse = Invoke-PowerBIRestMethod -Method GET -Url $dataflowsUrl | ConvertFrom-Json

    # Ensure response is not null before looping
    if ($dataflowsResponse.value) {
        foreach ($dataflow in $dataflowsResponse.value) {
            $renamedDataflow = Rename-Properties -object $dataflow -renameMap $dataflowRenameMap
            $renamedDataflow | Add-Member -NotePropertyName "WorkspaceId" -NotePropertyValue $workspace.WorkspaceId -Force
            $renamedDataflow | Add-Member -NotePropertyName "WorkspaceName" -NotePropertyValue $workspace.WorkspaceName -Force

            # Store DataflowId and DataflowName in a lookup table
            if ($dataflow.objectId) {  
                $dataflowNameLookup[$dataflow.objectId] = $dataflow.name  
            }

            $dataflowsInfo += $renamedDataflow

            # Fetch Dataflow Datasources
            $dataflowSourcesUrl = "https://api.powerbi.com/v1.0/myorg/groups/$($workspace.WorkspaceId)/dataflows/$($dataflow.objectId)/datasources"
            $dataflowSourcesResponse = Invoke-PowerBIRestMethod -Method GET -Url $dataflowSourcesUrl | ConvertFrom-Json

            # Ensure response is not null before looping
            if ($dataflowSourcesResponse.value) {
                foreach ($datasource in $dataflowSourcesResponse.value) {
                    $renamedDataflowDatasource = Rename-Properties -object $datasource -renameMap $dataflowDatasourceRenameMap

                    # Ensure required fields are included
                    $renamedDataflowDatasource | Add-Member -NotePropertyName "WorkspaceId" -NotePropertyValue $workspace.WorkspaceId -Force
                    $renamedDataflowDatasource | Add-Member -NotePropertyName "WorkspaceName" -NotePropertyValue $workspace.WorkspaceName -Force
                    $renamedDataflowDatasource | Add-Member -NotePropertyName "DataflowId" -NotePropertyValue $dataflow.objectId -Force

            		if ($datasource.connectionDetails) {
               		 $renamedDataflowDatasource.DataflowDatasourceConnectionDetails = $datasource.connectionDetails | ConvertTo-Json -Compress
            }
                    

                    if ($dataflowNameLookup.ContainsKey($dataflow.objectId)) {
                        $renamedDataflowDatasource | Add-Member -NotePropertyName "DataflowName" -NotePropertyValue $dataflowNameLookup[$dataflow.objectId] -Force
                    } else {
                        $renamedDataflowDatasource | Add-Member -NotePropertyName "DataflowName" -NotePropertyValue "Unknown Dataflow" -Force
                    }

                    # Store in collection
                    $dataflowSourcesInfo += $renamedDataflowDatasource
                }
            }
        }
    }
Write-Output "Workspace [$($workspace.WorkspaceName)] Dataflow metadata extraction process started."
} 


# Fetch Dataflow Lineage (Upstream Dataflows)
foreach ($workspace in $workspacesInfo) {

        $dataflowLineageUrl = "https://api.powerbi.com/v1.0/myorg/groups/$($workspace.WorkspaceId)/datasets/upstreamDataflows"
        $dataflowLineageResponse = Invoke-PowerBIRestMethod -Method GET -Url $dataflowLineageUrl | ConvertFrom-Json

        # Ensure response is not null before looping
        if ($dataflowLineageResponse.value) {
            foreach ($dataflow in $dataflowLineageResponse.value) {
                $renamedDataflow = Rename-Properties -object $dataflow -renameMap $dataflowLineageRenameMap
                $renamedDataflow | Add-Member -NotePropertyName "WorkspaceId" -NotePropertyValue $workspace.WorkspaceId -Force
                $renamedDataflow | Add-Member -NotePropertyName "WorkspaceName" -NotePropertyValue $workspace.WorkspaceName -Force


                $dataflowId = $dataflow.dataflowObjectId  
                if ($dataflowId -and $dataflowNameLookup.ContainsKey($dataflowId)) {
                    $renamedDataflow | Add-Member -NotePropertyName "DataflowName" -NotePropertyValue $dataflowNameLookup[$dataflowId] -Force
                } else {
                    $renamedDataflow | Add-Member -NotePropertyName "DataflowName" -NotePropertyValue "Unknown Dataflow" -Force
                }

            $datasetId = $dataflow.datasetObjectId  
            if ($datasetId -and $datasetNameLookup.ContainsKey($datasetId)) {
                $renamedDataflow | Add-Member -NotePropertyName "DatasetName" -NotePropertyValue $datasetNameLookup[$datasetId] -Force
            } else {
                $renamedDataflow | Add-Member -NotePropertyName "DatasetName" -NotePropertyValue "Unknown Dataset" -Force
            }

                $dataflowLineage += $renamedDataflow
            }
        }
    }

# Fetch Dataflow Refresh History
foreach ($workspace in $workspacesInfo) {
Write-Output "Workspace [$($workspace.WorkspaceName)] Dataflow Refresh History extraction process started."
    foreach ($dataflow in $dataflowsInfo | Where-Object { $_.WorkspaceId -eq $workspace.WorkspaceId }) {
        $refreshHistoryUrl = "https://api.powerbi.com/v1.0/myorg/groups/$($workspace.WorkspaceId)/dataflows/$($dataflow.DataflowId)/transactions"
        $refreshHistoryResponse = Invoke-PowerBIRestMethod -Method GET -Url $refreshHistoryUrl | ConvertFrom-Json

        # Ensure response is not null before looping
        if ($refreshHistoryResponse.value) {
            foreach ($refresh in $refreshHistoryResponse.value) {
                $renamedRefreshRecord = Rename-Properties -object $refresh -renameMap $dataflowRefreshRenameMap
                $renamedRefreshRecord | Add-Member -NotePropertyName "WorkspaceId" -NotePropertyValue $workspace.WorkspaceId -Force
                $renamedRefreshRecord | Add-Member -NotePropertyName "WorkspaceName" -NotePropertyValue $workspace.WorkspaceName -Force
                $renamedRefreshRecord | Add-Member -NotePropertyName "DataflowId" -NotePropertyValue $dataflow.DataflowId -Force
                

                if ($dataflowNameLookup.ContainsKey($dataflow.DataflowId)) {
                    $renamedRefreshRecord | Add-Member -NotePropertyName "DataflowName" -NotePropertyValue $dataflowNameLookup[$dataflow.DataflowId] -Force
                } else {
                    $renamedRefreshRecord | Add-Member -NotePropertyName "DataflowName" -NotePropertyValue "Unknown Dataflow" -Force
                }

                # Store in collection
                $dataflowRefreshHistory += $renamedRefreshRecord
            }
        }
    }
Write-Output "Workspace [$($workspace.WorkspaceName)] Dataflow Refresh History extraction process completed."
}

# Loop through all workspaces to fetch Fabric Items (excluding Reports and Semantic Models)
foreach ($workspace in $workspacesInfo) {

Write-Output "Workspace [$($workspace.WorkspaceName)] Fabric Item metadata extraction process started."

    $workspaceId = $workspace.WorkspaceId
    $workspaceName = $workspace.WorkspaceName
    $fabricItemsUrl = "https://api.fabric.microsoft.com/v1/workspaces/$workspaceId/items"

    try {
        $fabricItemsResponse = Invoke-PowerBIRestMethod -Method GET -Url $fabricItemsUrl | ConvertFrom-Json


        $filteredItems = $fabricItemsResponse.value | Where-Object {
            $_.type -ne 'Report' -and $_.type -ne 'SemanticModel'
        }

        foreach ($item in $filteredItems) {
            $renamedItem = Rename-Properties -object $item -renameMap $fabricItemsRenameMap
            $renamedItem | Add-Member -NotePropertyName "WorkspaceId" -NotePropertyValue $workspaceId -Force
            $renamedItem | Add-Member -NotePropertyName "WorkspaceName" -NotePropertyValue $workspaceName -Force

            $fabricItemsInfo += $renamedItem
        }
    } catch {
        Write-Warning "Failed to fetch Fabric items for Workspace ID: $workspaceId. $_"
    }

Write-Output "Workspace [$($workspace.WorkspaceName)] Fabric Item metdadata extraction process completed."

}






Write-Output "My Workspace Metadata Extract Process Started"


#### Start of 'My Workspace' detail extract ####

if ($IncludeMyWorkspace -or ($selection -and $selection.TimedOut)) {

    # Define "My Workspace" constants
    $myWorkspaceId = "My Workspace"
    $myWorkspaceName = "My Workspace"

    # Manually add "My Workspace" breakdown to workspacesInfo
    $myWorkspaceDetails = [PSCustomObject]@{
        WorkspaceId                      = $myWorkspaceId
        WorkspaceName                    = $myWorkspaceName
        WorkspaceType                    = "Workspace"
        WorkspaceIsReadOnly              = $false
        WorkspaceIsOnDedicatedCapacity   = $false
    }
    $workspacesInfo += $myWorkspaceDetails

    # Fetch datasets from "My Workspace"
    $myWorkspaceDatasetsUrl = "https://api.powerbi.com/v1.0/myorg/datasets"
    $myWorkspaceDatasets = Invoke-PowerBIRestMethod -Method GET -Url $myWorkspaceDatasetsUrl | ConvertFrom-Json
    foreach ($dataset in $myWorkspaceDatasets.value) {
        $renamedDataset = Rename-Properties -object $dataset -renameMap $datasetRenameMap
        $renamedDataset | Add-Member -NotePropertyName "WorkspaceId" -NotePropertyValue $myWorkspaceId -Force
        $renamedDataset | Add-Member -NotePropertyName "WorkspaceName" -NotePropertyValue $myWorkspaceName -Force
        $datasetNameLookup[$dataset.id] = $dataset.name
        $datasetsInfo += $renamedDataset

        $datasourcesUrl = "https://api.powerbi.com/v1.0/myorg/datasets/$($dataset.id)/datasources"
        $datasources = Invoke-PowerBIRestMethod -Method GET -Url $datasourcesUrl | ConvertFrom-Json
        foreach ($datasource in $datasources.value) {
            $renamedDatasource = Rename-Properties -object $datasource -renameMap $datasetDatasourceRenameMap
            $renamedDatasource | Add-Member -NotePropertyName "WorkspaceId" -NotePropertyValue $myWorkspaceId -Force
            $renamedDatasource | Add-Member -NotePropertyName "WorkspaceName" -NotePropertyValue $myWorkspaceName -Force
            $renamedDatasource | Add-Member -NotePropertyName "DatasetId" -NotePropertyValue $dataset.id -Force
            $renamedDatasource | Add-Member -NotePropertyName "DatasetName" -NotePropertyValue $dataset.name -Force
            if ($datasource.connectionDetails) {
                $renamedDatasource.DatasetDatasourceConnectionDetails = $datasource.connectionDetails | ConvertTo-Json -Compress
            }
            $datasetSourcesInfo += $renamedDatasource
        }
    }

    # Fetch reports from "My Workspace"
    $myWorkspaceReportsUrl = "https://api.powerbi.com/v1.0/myorg/reports"
    $myWorkspaceReports = Invoke-PowerBIRestMethod -Method GET -Url $myWorkspaceReportsUrl | ConvertFrom-Json

    $sharedReportExists = $false
    foreach ($report in $myWorkspaceReports.value) {
        # Skip if already captured elsewhere (workspace/app)
        if ($appReportIds.ContainsKey($report.id) -or $reportIds.ContainsKey($report.id) -or $originalReportObjectIds.ContainsKey($report.id)) {
            continue
        }

        if ($report.isOwnedByMe -eq $false) {
            $workspaceIdValue = "Shared Reports (No Workspace Access)"
            $workspaceNameValue = "Shared Reports (No Workspace Access)"
            $sharedReportExists = $true
        } else {
            $workspaceIdValue = $myWorkspaceId
            $workspaceNameValue = $myWorkspaceName
        }

        $renamedReport = Rename-Properties -object $report -renameMap $reportRenameMap
        $renamedReport | Add-Member -NotePropertyName "WorkspaceId" -NotePropertyValue $workspaceIdValue -Force
        $renamedReport | Add-Member -NotePropertyName "WorkspaceName" -NotePropertyValue $workspaceNameValue -Force

        $datasetId = $report.datasetId
        if ($datasetId -and $datasetNameLookup.ContainsKey($datasetId)) {
            $renamedReport | Add-Member -NotePropertyName "DatasetName" -NotePropertyValue $datasetNameLookup[$datasetId] -Force
        } else {
            $renamedReport | Add-Member -NotePropertyName "DatasetName" -NotePropertyValue "Unknown Dataset" -Force
        }
        $reportsInfo += $renamedReport

        $pagesUrl = "https://api.powerbi.com/v1.0/myorg/reports/$($report.id)/pages"
        $pages = Invoke-PowerBIRestMethod -Method GET -Url $pagesUrl | ConvertFrom-Json
        foreach ($page in $pages.value) {
            $renamedPage = Rename-Properties -object $page -renameMap $pageRenameMap
            $renamedPage | Add-Member -NotePropertyName "WorkspaceId" -NotePropertyValue $workspaceIdValue -Force
            $renamedPage | Add-Member -NotePropertyName "WorkspaceName" -NotePropertyValue $workspaceNameValue -Force
            $renamedPage | Add-Member -NotePropertyName "ReportId" -NotePropertyValue $report.id -Force
            $renamedPage | Add-Member -NotePropertyName "ReportName" -NotePropertyValue $report.name -Force
            $reportPagesInfo += $renamedPage
        }
    }

    if ($sharedReportExists) {
        $sharedWorkspaceDetails = [PSCustomObject]@{
            WorkspaceId                    = "Shared Reports (No Workspace Access)"
            WorkspaceName                  = "Shared Reports (No Workspace Access)"
            WorkspaceType                  = "Workspace"
            WorkspaceIsReadOnly            = $false
            WorkspaceIsOnDedicatedCapacity = $false
        }
        $workspacesInfo += $sharedWorkspaceDetails
    }

    # Dataset refresh history for My Workspace
    foreach ($dataset in $datasetsInfo | Where-Object { $_.WorkspaceId -eq $myWorkspaceId }) {
        $refreshHistoryUrl = "https://api.powerbi.com/v1.0/myorg/datasets/$($dataset.DatasetId)/refreshes"
        $refreshHistoryResponse = Invoke-PowerBIRestMethod -Method GET -Url $refreshHistoryUrl | ConvertFrom-Json
        foreach ($refresh in $refreshHistoryResponse.value) {
            $renamedRefreshRecord = Rename-Properties -object $refresh -renameMap $datasetRefreshRenameMap
            $renamedRefreshRecord | Add-Member -NotePropertyName "WorkspaceId" -NotePropertyValue $myWorkspaceId -Force
            $renamedRefreshRecord | Add-Member -NotePropertyName "WorkspaceName" -NotePropertyValue $myWorkspaceName -Force
            $renamedRefreshRecord | Add-Member -NotePropertyName "DatasetId" -NotePropertyValue $dataset.DatasetId -Force
            $renamedRefreshRecord | Add-Member -NotePropertyName "DatasetName" -NotePropertyValue $dataset.DatasetName -Force
            $datasetRefreshHistory += $renamedRefreshRecord
        }
    }

} else {
    Write-Host "Skipping 'My Workspace' (user did not select it and no timeout)."
}
    
Write-Output "My Workspace Metadata Extract Process Completed"


# Export all collections to Excel
if (Test-Path $excelFile) {
    Remove-Item $excelFile -Force
}

$workspacesInfo | Export-Excel -Path $excelFile -WorksheetName "Workspaces" -AutoSize
$fabricItemsInfo | Export-Excel -Path $excelFile -WorksheetName "FabricItems" -AutoSize -Append
$datasetsInfo | Export-Excel -Path $excelFile -WorksheetName "Datasets" -AutoSize -Append
$datasetSourcesInfo | Export-Excel -Path $excelFile -WorksheetName "DatasetSourcesInfo" -AutoSize -Append
$datasetRefreshHistory | Export-Excel -Path $excelFile -WorksheetName "DatasetRefreshHistory" -AutoSize -Append
$dataflowsInfo | Export-Excel -Path $excelFile -WorksheetName "Dataflows" -AutoSize -Append
$dataflowLineage | Export-Excel -Path $excelFile -WorksheetName "DataflowLineage" -AutoSize -Append
$dataflowSourcesInfo | Export-Excel -Path $excelFile -WorksheetName "DataflowSourcesInfo" -AutoSize -Append
$dataflowRefreshHistory | Export-Excel -Path $excelFile -WorksheetName "DataflowRefreshHistory" -AutoSize -Append
$reportsInfo | Export-Excel -Path $excelFile -WorksheetName "Reports" -AutoSize -Append
$reportPagesInfo | Export-Excel -Path $excelFile -WorksheetName "ReportPages" -AutoSize -Append
$appsInfo | Export-Excel -Path $excelFile -WorksheetName "Apps" -AutoSize -Append
$reportsInAppInfo | Export-Excel -Path $excelFile -WorksheetName "AppReports" -AutoSize -Append

Write-Host "Export completed. Data is saved to $excelFile"  

Write-Output "Power BI Environment Detail Extract Process Completed. Excel output saved to $excelFile"







#### Start of Model Backup ####








Write-Output "Model Backup Process Started"

# Loop through datasetsInfo collection to perform model export
foreach ($dataset in $datasetsInfo) {
    # Get workspace details
    $workspace = $workspacesInfo | Where-Object { $_.WorkspaceId -eq $dataset.WorkspaceId }

        # Construct the folder path and create it if it doesn't exist
        $modelBackupsPath = "$baseFolderPath\Model Backups"
        if (-not (Test-Path $modelBackupsPath)) {
            New-Item -ItemType Directory -Force -Path $modelBackupsPath
        }

        # Construct the date model backup folder path and create it if it doesn't exist
        $folderPath = "$modelBackupsPath\$date"
        if (-not (Test-Path $folderPath)) {
            New-Item -ItemType Directory -Force -Path $folderPath
        }

    # Check if the workspace is Premium or Fabric capacity before proceeding
    if ($workspace.WorkspaceIsOnDedicatedCapacity -eq $true) {

        $workspaceName = $dataset.WorkspaceName -replace '\[', '%5B' -replace '\]', '%5D' -replace ' ', '%20'
        $datasetId = $dataset.DatasetId
        $datasetName = $dataset.DatasetName

        # Clean up workspace name
        $cleanDatasetWorkspaceName = $dataset.WorkspaceName -replace '\[', '(' -replace '\]', ')'
        $cleanDatasetWorkspaceName = $cleanDatasetWorkspaceName -replace "[^a-zA-Z0-9\(\)&,.-]", " "
        $cleanDatasetWorkspaceName = $cleanDatasetWorkspaceName.TrimStart()

        # Clean up dataset name
        $cleanDatasetName = $datasetName -replace '\[', '(' -replace '\]', ')'
        $cleanDatasetName = $cleanDatasetName -replace "[^a-zA-Z0-9\(\)&,.-]", " "
        $cleanDatasetName = $cleanDatasetName.TrimStart()

        # Define the new model database name
        $newModelDatabaseName = "$cleanDatasetWorkspaceName ~ $cleanDatasetName"

        # Create the C# script to rename the Model.Database.Name
        $csharpScript = @"
Model.Database.Name = `"$newModelDatabaseName`";
"@

        # Save the C# script to a temporary file	
	$tempScriptPath = Join-Path $env:TEMP "TabularEditor_RenameModel.cs"
	Set-Content -Path $tempScriptPath -Value $csharpScript -Encoding UTF8


        # Construct the argument list for the model export with renaming
        $modelExportArgs = "`"Provider=MSOLAP;Data Source=powerbi://api.powerbi.com/v1.0/myorg/$workspaceName;Password=$(Get-CurrentAccessToken)`" `"$datasetName`" -S `"$tempScriptPath`" -B `"$folderPath\$cleanDatasetWorkspaceName ~ $cleanDatasetName.bim`""
        
        # Start the Tabular Editor process for model export and renaming
        Start-Process -FilePath "$TabularEditor2Path" -Wait -NoNewWindow -PassThru -ArgumentList $modelExportArgs

        # Clean up the temporary script file
        Remove-Item -Path $tempScriptPath
    }
}

Write-Output "Model Backup Process Completed"







#### Start of Report Backup ####







Write-Output "Report Backup Process Started"

# Define the report backups path
$reportBackupsPath = Join-Path -Path $baseFolderPath -ChildPath "Report Backups"

# Check if the base folder exists, if not create it
if (-not (Test-Path -Path $baseFolderPath)) {
    New-Item -Path $baseFolderPath -ItemType Directory -Force
}

# Check if the "Report Backups" folder exists, if not create it
if (-not (Test-Path -Path $reportBackupsPath)) {
    New-Item -Path $reportBackupsPath -ItemType Directory -Force
}

# Create a new sub folder for the date
$newDateFolder = Join-Path -Path $reportBackupsPath -ChildPath $date
if (-not (Test-Path -Path $newDateFolder)) {
    New-Item -Path $newDateFolder -ItemType Directory -Force
}

# Define the temporary extraction folder
$tempExtractFolder = "$baseFolderPath\Config\Temp"

# Check if the temp extract folder exists, if not create it
if (-not (Test-Path -Path $tempExtractFolder)) {
    New-Item -Path $tempExtractFolder -ItemType Directory -Force
}

# Function to Export Using REST API and Stored Token
function Export-ReportUsingAPI {
    param (
        [string]$GroupId,
        [string]$ReportId,
        [string]$OutFilePath,
        [string]$DownloadType
    )

    $accessToken = Get-CurrentAccessToken
    $apiUrl = "https://api.powerbi.com/v1.0/myorg/groups/$GroupId/reports/$ReportId/Export?downloadType=$DownloadType"

    try {
        Invoke-RestMethod -Uri $apiUrl `
            -Headers @{ Authorization = "Bearer $accessToken" } `
            -Method GET `
            -OutFile $OutFilePath
    } catch {
        
    }
}

	# -------------------
	# Helper Function(s)
	# -------------------
	
	# Function: get first free drive letter (Z down to D)
	function Get-FreeDriveLetter {
	    $used = Get-PSDrive -PSProvider FileSystem | ForEach-Object { $_.Name }
	    foreach ($letter in [char[]](90..68)) {  # Z..Y..X.. down to D
	        if ($used -notcontains $letter) { return "${letter}:" }
	    }
	    throw "No free drive letters available."
	}

	foreach ($workspace in $workspacesInfo) {
	    $workspaceName = $workspace.WorkspaceName
	    $workspaceId = $workspace.WorkspaceId
	
	    # Clean up workspace name
	    $cleanWorkspaceName = $workspaceName -replace '\[', '(' -replace '\]', ')'
	    $cleanWorkspaceName = $cleanWorkspaceName -replace "[^a-zA-Z0-9\(\)&,.-]", " "
	    $cleanWorkspaceName = $cleanWorkspaceName.TrimStart()
	
	    # Fetch reports from the existing list
	    $reports = $reportsInfo | Where-Object { $_.WorkspaceId -eq $workspaceId }
	
	    foreach ($report in $reports) {
	        $reportName = $report.ReportName
	        $reportId = $report.ReportId
	
	        # Clean up report name
	        $cleanReportName = $reportName -replace '\[', '(' -replace '\]', ')'
	        $cleanReportName = $cleanReportName -replace "[^a-zA-Z0-9\(\)&,.-]", " "
	        $cleanReportName = $cleanReportName.TrimStart()
	
	        # Determine file extension
	        $fileExtension = if ($report.WebUrl -like "*/rdlreports/*") { "rdl" } else { "pbix" }
	        $filename = "$cleanWorkspaceName ~ $cleanReportName.$fileExtension"
	        $filepath = Join-Path -Path $newDateFolder -ChildPath $filename
	        $extractFolder = Join-Path -Path $tempExtractFolder -ChildPath "$cleanWorkspaceName ~ $cleanReportName"
	
	        # Delete file if it already exists
	        if (Test-Path $filepath) {
	            Remove-Item $filepath -Force
	        }
	
	        Write-Host "Exporting $cleanWorkspaceName ~ $cleanReportName"
	
	        # Export based on Workspace Type
	        if ($workspace.WorkspaceIsOnDedicatedCapacity -eq $false) {
	            # Pro Workspace → IncludeModel
	            Export-ReportUsingAPI -GroupId $workspaceId -ReportId $reportId -OutFilePath $filepath -DownloadType "IncludeModel"
	        } else {
	            # Premium/Fabric Workspace → LiveConnect
	            Export-ReportUsingAPI -GroupId $workspaceId -ReportId $reportId -OutFilePath $filepath -DownloadType "LiveConnect"
	        }
			
		# Only process model extraction for Pro Workspaces
		if ($workspace.WorkspaceIsOnDedicatedCapacity -eq $false) {
		    Write-Host "Extracting $cleanWorkspaceName ~ $cleanReportName"
		
		    $driveLetter = Get-FreeDriveLetter
		    $quotedExtractFolder = "`"$extractFolder`""
		
		    # ✅ Make sure the extract folder exists before subst
		    if (-not (Test-Path $extractFolder)) {
		        New-Item -ItemType Directory -Path $extractFolder -Force | Out-Null
		    }
		
		    if (Test-Path $driveLetter) { subst $driveLetter /D }
		
		    $substCommand = "subst $driveLetter $quotedExtractFolder"
		    Write-Host "Running command: $substCommand"
		    cmd.exe /c $substCommand
		
		    if (-not (Test-Path $driveLetter)) {
		        Write-Error "Failed to map $extractFolder to $driveLetter"
		        continue
		    }
		
		    try {
		        # Extract into subst drive
		        & $pbiToolsPath extract $filepath -extractFolder $driveLetter -modelSerialization Raw
		
		        Write-Host "Generating .bim for $cleanWorkspaceName ~ $cleanReportName using $driveLetter"
		        & $pbiToolsPath generate-bim $driveLetter -transforms RemovePBIDataSourceVersion
		
		        $bimFilesGenerated = Get-ChildItem -Path $extractFolder -Filter *.bim
		        foreach ($bimFile in $bimFilesGenerated) {
		            $newBimName = "$cleanWorkspaceName ~ $cleanReportName.bim"
		            $newBimPath = Join-Path -Path $tempExtractFolder -ChildPath $newBimName
		
		            Move-Item -Path $bimFile.FullName -Destination $newBimPath -Force
		            Write-Host "Moved .bim file to $newBimPath"
		        }
		    }
		    finally {
		        # ✅ Always clean up subst drive, even if extract/generate fails
		        subst $driveLetter /D 2>$null
		    }
		}
	}
}

# --- Process and Move .bim files ---
# Path to Tabular Editor executable
$TabularEditor2Path = "$baseFolderPath\Config\TabularEditor\TabularEditor.exe"

$bimFiles = Get-ChildItem -Path $tempExtractFolder -Recurse -Filter *.bim
foreach ($bimFile in $bimFiles) {
    $fileName = [System.IO.Path]::GetFileNameWithoutExtension($bimFile.Name)

    # Build temporary C# script
    $csharpScript = @"
Model.Database.Name = "$fileName";
Model.Database.ID = "$fileName";
"@

    # Save script to temp
    $tempScriptPath = Join-Path $env:TEMP "TabularEditor_RenameProModel.cs"
    Set-Content -Path $tempScriptPath -Value $csharpScript -Encoding UTF8

    # Run Tabular Editor CLI to update BIM
    $args = "`"$($bimFile.FullName)`" -S `"$tempScriptPath`" -B `"$($bimFile.FullName)`""
    Start-Process -FilePath $TabularEditor2Path -Wait -NoNewWindow -ArgumentList $args

    # Remove temp script
    Remove-Item -Path $tempScriptPath -Force

    # Move updated BIM to backup folder
    $destinationPath = Join-Path -Path $folderPath -ChildPath $bimFile.Name
    Move-Item -Path $bimFile.FullName -Destination $destinationPath -Force

    Write-Host "Updated and moved $fileName.bim"
}

# --- Cleanup Temporary Folders ---
$tempDestinationRemovalPath = "$baseFolderPath\Config"

Remove-Item -Path "$tempDestinationRemovalPath\Temp" -Recurse -Force -ErrorAction SilentlyContinue
Remove-Item -Path "$tempDestinationRemovalPath\localhost" -Recurse -Force -ErrorAction SilentlyContinue
Remove-Item -Path "$baseFolderPath\localhost" -Recurse -Force -ErrorAction SilentlyContinue

Write-Output "Report Backup Process Completed"







#### Start of Tabular Editor Report Detail (Visual Object Layer) Extract ####







Write-Output "Report Detail Extraction Process Started"

# Start Tabular Editor process 1
$p = Start-Process -FilePath "$TabularEditor2Path" -Wait -NoNewWindow -PassThru -WorkingDirectory $baseFolderPath -ArgumentList "`"$baseFolderPath\Config\Blank Model.bim`" -S `"$Script1Path`""

# Start Tabular Editor process 2
$p = Start-Process -FilePath "$TabularEditor2Path" -Wait -NoNewWindow -PassThru -WorkingDirectory $baseFolderPath -ArgumentList "`"$baseFolderPath\Config\Blank Model.bim`" -S `"$Script2Path`""

# Define the output Excel file path in the parent folder
$outputExcelFile = Join-Path -Path $baseFolderPath -ChildPath "Report Detail.xlsx"

# Check if the Excel file already exists and delete it if it does
if (Test-Path -Path $outputExcelFile) {
    Remove-Item $outputExcelFile -Force
    $excelExists = $false
} else {
    $excelExists = $false
}

# Get the latest folder by date
$latestDateFolder = Get-ChildItem -Path $reportBackupsPath -Directory |
    Where-Object { $_.Name -match '^\d{4}-\d{2}-\d{2}$' } |  # Filter for folders with a date pattern
    Sort-Object { [datetime]::Parse($_.Name) } -Descending | # Sort by date, descending
    Select-Object -First 1

if ($latestDateFolder) {
    $newDateFolder = $latestDateFolder.FullName
    Write-Host "Using the latest dated folder: $newDateFolder"
} else {
    Write-Error "No valid dated folders found in 'Report Backups'."
}

foreach ($txtFile in (Get-ChildItem -Path $newDateFolder -Filter *.txt)) {
    $worksheetName = [System.IO.Path]::GetFileNameWithoutExtension($txtFile.FullName)
    
    # Read raw lines without automatically trimming leading or trailing spaces
    $lines = Get-Content -Path $txtFile.FullName -Encoding UTF8
    $headers = $lines[0] -split "`t"
    $data = $lines[1..($lines.Count - 1)] | ForEach-Object {
        $values = $_ -split "`t", -1  # -1 keeps empty trailing fields and preserves spaces
        $obj = @{}
        for ($i = 0; $i -lt $headers.Length; $i++) {
            $obj[$headers[$i]] = $values[$i]
        }
        [PSCustomObject]$obj
    }

    if ($excelExists) {
        $data | Export-Excel -Path $outputExcelFile -WorksheetName $worksheetName -AutoNameRange -Append
    } else {
        $data | Export-Excel -Path $outputExcelFile -WorksheetName $worksheetName -AutoNameRange
        $excelExists = $true
    }
}



Write-Host "TXT files appended to $outputExcelFile"



#### Cleanup Visual Object folders Remaining ####


# Check if the any remaining VOL folders exists
if (Test-Path -Path $newDateFolder) {
    # Get all subfolders
    $subfolders = Get-ChildItem -Path $newDateFolder -Directory

    foreach ($subfolder in $subfolders) {
        Remove-Item -Path $subfolder.FullName -Recurse -Force
    }

    Write-Host "Additional Subfolders in $newDateFolder deleted"
} else {
    Write-Host "Additional Subfolders in $newDateFolder do not exist"
}

Write-Output "Report Detail Extraction Process Completed. Excel output saved to $outputExcelFile"








#### Start of Model Detail Script Run with Script3Path ####







Write-Output "Model Detail Extraction Process Started"

$latestModelDateFolder = Get-ChildItem -Path $modelBackupsPath -Directory |
    Where-Object { $_.Name -match '^\d{4}-\d{2}-\d{2}$' } |  # Filter for folders with a date pattern
    Sort-Object { [datetime]::Parse($_.Name) } -Descending | # Sort by date, descending
    Select-Object -First 1

if ($latestModelDateFolder) {
    # Override $folderPath with the latest-dated folder
    $folderPath = $latestModelDateFolder.FullName
    Write-Host "Using the latest dated folder: $folderPath"
} else {
    # Throw an error if no valid dated folders are found
    Write-Error "No valid dated folders found in 'Model Backups'."
}

# Check if there are any .bim files in the $folderPath
$folderPathBimFiles = Get-ChildItem -Path $folderPath -Filter *.bim
if ($folderPathBimFiles.Count -eq 0) {
    $sourceFolderPath = $newDateFolder
} else {
    $sourceFolderPath = $folderPath
}


# Loop through datasetsInfo collection to run the first model script
foreach ($dataset in $datasetsInfo) {
    $workspaceName = $dataset.WorkspaceName
    $datasetName = $dataset.DatasetName

    # Clean up workspace name
    $cleanDatasetWorkspaceName = $workspaceName -replace '\[', '(' -replace '\]', ')'
    $cleanDatasetWorkspaceName = $cleanDatasetWorkspaceName -replace "[^a-zA-Z0-9\(\)&,.-]", " "
    $cleanDatasetWorkspaceName = $cleanDatasetWorkspaceName.TrimStart()

    # Clean up dataset name
    $cleanDatasetName = $datasetName -replace '\[', '(' -replace '\]', ')'
    $cleanDatasetName = $cleanDatasetName -replace "[^a-zA-Z0-9\(\)&,.-]", " "
    $cleanDatasetName = $cleanDatasetName.TrimStart()

    # Construct the argument list for the first model script run
    $modelScriptArgs = "`"$sourceFolderPath\$cleanDatasetWorkspaceName ~ $cleanDatasetName.bim`" -S `"$Script3Path`""
    
    # Start the Tabular Editor process to run the first model script
    Start-Process -FilePath "$TabularEditor2Path" -WorkingDirectory $baseFolderPath -Wait -NoNewWindow -PassThru -ArgumentList $modelScriptArgs
}

Write-Host "First model export and script run completed."


#### Start of PowerShell Combining to Semantic Models Worksheet ####



# Define the output Excel file path in the base folder
$outputExcelFile = Join-Path -Path $baseFolderPath -ChildPath "Model Detail.xlsx"

# Check if the Excel file already exists and delete it if it does
if (Test-Path -Path $outputExcelFile) {
    Remove-Item $outputExcelFile -Force
}

# Initialize an empty array to store all CSV data for Semantic Models
$semanticModelsCsvData = @()

foreach ($csvFile in (Get-ChildItem -Path $folderPath -Filter *.csv)) {
    # Exclude files that end with "_MD.csv" for Semantic Models
    if ($csvFile.Name -notlike "*_MD.csv") {
        # Import the CSV file
        $csvData = Import-Csv -Path $csvFile.FullName

        # Append the data to the array
        $semanticModelsCsvData += $csvData
    }
}

# Create a new Excel file with the data in the "Semantic Models" worksheet
$semanticModelsCsvData | Export-Excel -Path $outputExcelFile -WorksheetName "Semantic Models" -AutoNameRange

Write-Host "CSV files combined into the 'Semantic Models' worksheet in $outputExcelFile"
Write-Output "Model Detail Extraction Process Completed"



#### Start of Model Detail Script Run with Script4Path ####



Write-Output "Measure Dependency Detail Extraction Process Started"

# Loop through datasetsInfo collection to run the second model script
foreach ($dataset in $datasetsInfo) {
    $workspaceName = $dataset.WorkspaceName
    $datasetName = $dataset.DatasetName

    # Clean up workspace name
    $cleanDatasetWorkspaceName = $workspaceName -replace '\[', '(' -replace '\]', ')'
    $cleanDatasetWorkspaceName = $cleanDatasetWorkspaceName -replace "[^a-zA-Z0-9\(\)&,.-]", " "
    $cleanDatasetWorkspaceName = $cleanDatasetWorkspaceName.TrimStart()

    # Clean up dataset name
    $cleanDatasetName = $datasetName -replace '\[', '(' -replace '\]', ')'
    $cleanDatasetName = $cleanDatasetName -replace "[^a-zA-Z0-9\(\)&,.-]", " "
    $cleanDatasetName = $cleanDatasetName.TrimStart()

    # Construct the argument list for the second model script run
    $modelScriptArgs = "`"$sourceFolderPath\$cleanDatasetWorkspaceName ~ $cleanDatasetName.bim`" -S `"$Script4Path`""
    
    # Start the Tabular Editor process to run the second model script
    Start-Process -FilePath "$TabularEditor2Path" -WorkingDirectory $baseFolderPath -Wait -NoNewWindow -PassThru -ArgumentList $modelScriptArgs
}

Write-Host "Second model export and script run completed."

#### Start of PowerShell Combining to Measure Dependencies Worksheet ####

# Initialize an empty array to store all CSV data for Measure Dependencies
$measureDependenciesCsvData = @()

foreach ($csvFile in (Get-ChildItem -Path $folderPath -Filter *.csv)) {
    # Include only files that end with "_MD.csv" for Measure Dependencies
    if ($csvFile.Name -like "*_MD.csv") {
        # Import the CSV file
        $csvData = Import-Csv -Path $csvFile.FullName

        # Append the data to the array
        $measureDependenciesCsvData += $csvData
    }
}

# Append data to the existing Excel file in the "Measure Dependencies" worksheet
$measureDependenciesCsvData | Export-Excel -Path $outputExcelFile -WorksheetName "Measure Dependencies" -AutoNameRange -Append

Write-Host "CSV files combined into the 'Measure Dependencies' worksheet in $outputExcelFile"

Write-Output "Measure Dependency Detail Extraction Process Completed. Excel output saved to $outputExcelFile"







#### Start of Power BI Dataflow Backup and Detail Extract ####







Write-Output "Dataflow Backup and Detail Extraction Process Started"

# Define the dataflow backups path
$dataflowBackupsPath = Join-Path -Path $baseFolderPath -ChildPath "Dataflow Backups"

# Check if the "Dataflow Backups" folder exists, if not create it
if (-not (Test-Path -Path $dataflowBackupsPath)) {
    New-Item -Path $dataflowBackupsPath -ItemType Directory
}

# Create a variable for end of week (Friday) date
$date = (Get-Date -UFormat "%Y-%m-%d")

# Create a new folder for the backups
$dataflow_new_date_folder = Join-Path -Path $dataflowBackupsPath -ChildPath $date
New-Item -Path $dataflow_new_date_folder -ItemType Directory -Force

# Set the base output file path
$baseOutputFilePath = $dataflow_new_date_folder

# Get the latest folder by date
$latestDataflowDateFolder = Get-ChildItem -Path $dataflowBackupsPath -Directory |
    Where-Object { $_.Name -match '^\d{4}-\d{2}-\d{2}$' } |  # Filter for folders with a date pattern
    Sort-Object { [datetime]::Parse($_.Name) } -Descending | # Sort by date, descending
    Select-Object -First 1

if ($latestDataflowDateFolder) {
    # Override $baseOutputFilePath with the latest-dated folder
    $folderPath = $latestDataflowDateFolder.FullName
    Write-Host "Using the latest dated folder: $baseOutputFilePath"
} else {
    # Throw an error if no valid dated folders are found
    Write-Error "No valid dated folders found in 'Dataflow Backups'."
    exit
}

# Set the combined Excel output path
$combinedExcelOutputPath = Join-Path -Path $dataflow_new_date_folder -ChildPath "Dataflow Detail.xlsx"

# Define the headers
$headers = @("Dataflow ID", "Dataflow Name", "Query Name", "Query", "Report Date", "Workspace Name - Dataflow Name")

# Initialize a combined DataTable with the specified headers
$combinedDataTable = New-Object System.Data.DataTable
foreach ($header in $headers) {
    $combinedDataTable.Columns.Add($header, [System.String])
}

# Get the current date
$currentDate = [datetime]::Parse($latestDataflowDateFolder.Name)

# Function to check if a position is within curly braces
function IsInsideCurlyBraces {
    param (
        [string]$text,
        [int]$position
    )
    $openBraces = 0
    for ($i = 0; $i -lt $position; $i++) {
        if ($text[$i] -eq '{') { $openBraces++ }
        elseif ($text[$i] -eq '}') { $openBraces-- }
    }
    return $openBraces -gt 0
}

# Loop through all workspaces to fetch dataflows


foreach ($workspace in $workspacesInfo) {
    $workspaceName = $workspace.WorkspaceName
    $workspaceId = $workspace.WorkspaceId

    # Set the Power BI REST API URL for the dataflow details
    $dataflowDetailsUrl = "https://api.powerbi.com/v1.0/myorg/groups/$workspaceId/dataflows"

    # Get the list of dataflows in the workspace
    $dataflowsResponse = Invoke-PowerBIRestMethod -Url $dataflowDetailsUrl -Method Get

    # Parse the JSON response
    $dataflows = $dataflowsResponse | ConvertFrom-Json

    # Check if the response is valid and contains dataflows
    if ($dataflows -and $dataflows.value) {
        Write-Host "Dataflows found in workspace '$workspaceName': $($dataflows.value.Count)"
        
        # Iterate through the dataflows
        foreach ($dataflow in $dataflows.value) {
            $dataflowId = $dataflow.objectId
            $dataflowName = $dataflow.name

            # Clean up workspace name
            $cleanWorkspaceName = $workspaceName -replace '\[', '(' -replace '\]', ')'
            $cleanWorkspaceName = $cleanWorkspaceName -replace "[^a-zA-Z0-9\(\)&,.-]", " "
            $cleanWorkspaceName = $cleanWorkspaceName.TrimStart()

            # Clean up dataflow name
            $cleanDataFlowName = $dataflowName -replace '\[', '(' -replace '\]', ')'
            $cleanDataFlowName = $cleanDataFlowName -replace "[^a-zA-Z0-9\(\)&,.-]", " "
            $cleanDataFlowName = $cleanDataFlowName.TrimStart()
            
            # Define output file path specific to the dataflow
            $dataflowOutputFilePath = Join-Path -Path $baseOutputFilePath -ChildPath "$cleanWorkspaceName ~ $cleanDataFlowName.txt"
            
            # Set the Power BI REST API URL for the specific dataflow
            $apiUrl = "https://api.powerbi.com/v1.0/myorg/groups/$workspaceId/dataflows/$dataflowId"
            
            # Get the dataflow
            $response = Invoke-PowerBIRestMethod -Url $apiUrl -Method Get
            
            # Convert the response to JSON string
            $jsonString = $response | ConvertTo-Json
            
            # Write the JSON string to a text file
            $jsonString | Out-File -FilePath $dataflowOutputFilePath -Encoding UTF8
            
            # Extract the data from the JSON response without writing intermediate files
            $startMarker = '"document\":'
            $endMarker = '\\r\\n\"'
            $startIndex = $jsonString.IndexOf($startMarker) + $startMarker.Length
            $endIndex = $jsonString.IndexOf($endMarker, $startIndex)
	    $fallbackEndMarker = '"connectionOverrides\"'

		# Extract start and end indices
		$startIndex = $jsonString.IndexOf($startMarker) + $startMarker.Length
		$endIndex = $jsonString.IndexOf($endMarker, $startIndex)

		# Check if $endMarker is valid; if not, look for fallback marker
		if ($endIndex -lt 0) {
		    $endIndex = $jsonString.IndexOf($fallbackEndMarker, $startIndex)
		}
            
            # Check if the startIndex and endIndex are valid
            if ($startIndex -ge 0 -and $endIndex -ge 0 -and $endIndex -gt $startIndex) {
                $documentContent = $jsonString.Substring($startIndex, $endIndex - $startIndex)
            } else {
                Write-Host "Invalid Start/End mark for dataflow '$dataflowName' in workspace '$workspaceName'."
                continue
            }

            # Format the extracted content
            $formattedText = $documentContent -replace '\\r\\n', "`n" `
                                                    -replace '\\\"', '"' `
                                                    -replace '\\\\', '\' `
                                                    -replace '(?<=\w)(=|then|else)(?=\w)', ' $1 ' `
                                                    -replace '(?<=then)\s+', ' ' `
                                                    -replace '\s+(?=else)', "`n    "

            # Additional formatting
            $insideQuotes = $false
            $formattedTextStep7 = ""
            for ($i = 0; $i -lt $formattedText.Length; $i++) {
                $char = $formattedText[$i]
                if ($char -eq '"') {
                    $insideQuotes = -not $insideQuotes
                }
                if ($char -eq ',' -and -not $insideQuotes -and -not (IsInsideCurlyBraces -text $formattedText -position $i)) {
                    $formattedTextStep7 += "$char`n    "
                } else {
                    $formattedTextStep7 += $char
                }
            }

            $formattedTextStep8 = $formattedTextStep7 -replace 'nshared', 'QueryStartandEndMarker' `
                                                      -replace '\\r', ' ' `
                                                      -replace '\\n', ' ' `
                                                      -replace '\\', '' `
                                                      -replace '\r\n', "`n" `
                                                      -replace '(?<!["\w])r(\s)(?![\w"])', '$1' `
                                                      -replace '\;r', ''

            $formattedTextStep9 = $formattedTextStep8 -replace '(?<=let|in|each)\s+', "`n    " `
                                                      -replace '(?<=,\s*)#', "`n    #"

            $formattedTextStep9 = $formattedTextStep9 -replace '(?<!\n)QueryStartandEndMarker\s', "`nQueryStartandEndMarker`n`n"

            $formattedTextStep9 = $formattedTextStep9 -replace '(^|\s)let', "`nlet"

            $formattedTextStep9 = $formattedTextStep9 -replace '\)  in', ")`n    in"

            # Read the content directly from the formatted text
            $fileContent = $formattedTextStep9

            # Initialize variables
            $inQuery = $false
            $queryName = ""
            $query = ""
            $data = @()

            # Split the content into lines
            $lines = $fileContent -split "`n"

            # Iterate over the lines
            foreach ($line in $lines) {
                if ($line -match 'QueryStartandEndMarker\s*') {
                    # If we find a new query, save the previous one
                    if ($queryName -ne "") {
                        $data += [PSCustomObject]@{
                            "Dataflow ID" = $dataflowId
                            "Dataflow Name" = $dataflowName
                            "Query Name" = $queryName
                            "Query" = $query.Trim()
                            "Report Date" = $currentDate
                            "Workspace Name - Dataflow Name" = "$cleanWorkspaceName ~ $cleanDataFlowName"  # Add data to new column
                        }
                    }
                    # Reset variables for new query
                    $inQuery = $true
                    $queryName = ""
                    $query = ""
                } elseif ($inQuery -and $line.Trim() -ne "") {
                    # Set the query name as the first non-empty line after QueryStartandEndMarker
                    if ($queryName -eq "") {
                        $queryName = $line.Trim()
                    } else {
                        # Append the line to the query
                        $query += "$line`n"
                    }
                } elseif ($queryName -ne "") {
                    # Append the line to the query
                    $query += "$line`n"
                }
            }

            # Add the last query
            if ($queryName -ne "") {
                $data += [PSCustomObject]@{
                    "Dataflow ID" = $dataflowId
                    "Dataflow Name" = $dataflowName
                    "Query Name" = $queryName
                    "Query" = $query.Trim()
                    "Report Date" = $currentDate
                    "Workspace Name - Dataflow Name" = "$cleanWorkspaceName ~ $cleanDataFlowName"  # Add data to new column
                }
            }

            # Fill the combined DataTable with data
            foreach ($item in $data) {
                $row = $combinedDataTable.NewRow()
                $row["Dataflow ID"] = $item."Dataflow ID"
                $row["Dataflow Name"] = $item."Dataflow Name"
                $row["Query Name"] = $item."Query Name"
                $row["Query"] = $item.Query
                $row["Report Date"] = $item."Report Date"
                $row["Workspace Name - Dataflow Name"] = $item."Workspace Name - Dataflow Name"  # Add data to new column
                $combinedDataTable.Rows.Add($row)
            }
        }
    } else {
        Write-Host "No dataflows found in workspace '$workspaceName'."
    }
}

# Check if the combined DataTable has any rows, if not add a dummy row with headers only
if ($combinedDataTable.Rows.Count -eq 0) {
    $row = $combinedDataTable.NewRow()
    foreach ($header in $headers) {
        $row[$header] = ""
    }
    $combinedDataTable.Rows.Add($row)
}



# Export the combined DataTable to an Excel file
$combinedDataTable | Export-Excel -Path $combinedExcelOutputPath -AutoSize
Write-Host "Data exported to $combinedExcelOutputPath"

# Combine files if both are there
$fileName = "Dataflow Detail.xlsx"
$sourceFilePath = Join-Path -Path $dataflow_new_date_folder -ChildPath $fileName
$destinationFilePath = Join-Path -Path $baseFolderPath -ChildPath $fileName

# Check if the source file exists
if (-not (Test-Path -Path $sourceFilePath)) {
    Write-Error "Source file not found: $sourceFilePath"
    exit
}

# Remove the destination file if it already exists
if (Test-Path -Path $destinationFilePath) {
    Remove-Item -Path $destinationFilePath -Force
}

# Copy the source file to the destination
Copy-Item -Path $sourceFilePath -Destination $destinationFilePath

# Load the source and destination Excel files
$sourceData = Import-Excel -Path $sourceFilePath
$destinationData = Import-Excel -Path $destinationFilePath

# Combine the data
$combinedData = $destinationData + $sourceData

# Export the combined data to the destination file
$combinedData | Export-Excel -Path $destinationFilePath -WorksheetName "Sheet1"

Write-Output "Dataflow Backup and Detail Extraction Process Completed. Excel output saved to $combinedExcelOutputPath"


# Stop the background job after script completion
Stop-Job -Name "TokenRefreshJob"
Remove-Job -Name "TokenRefreshJob"

Write-Output "All Excel files processed and combined successfully."

$scriptEndTime = Get-Date
$elapsedTime = New-TimeSpan -Start $scriptStartTime -End $scriptEndTime
Write-Output "Total Elapsed Time: $($elapsedTime.Hours)h $($elapsedTime.Minutes)m $($elapsedTime.Seconds)s"
 
